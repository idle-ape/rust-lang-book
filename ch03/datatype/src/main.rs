/*
四种基本的标量类型：
    1. 整型：包括无符号和有符号，比如：i8、i16、i32 ... 、isize; u8、u16、u32 ...、usize
    2. 浮点型：包括单精度 f32 和双精度 f64 两种，分别占 32 位和 64 位
    3. 字符：char 类型是 rust 中最原生的字母类型，该类型的大小为 4 个字节
    4. 布尔型：true 和 false

复合类型：
    1. 元组（tuple）：元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定，一旦声明，其长度不会增大或缩小。
    2. 数组（array）：数组是一个包含多个相同类型值的复合类型，数组是固定长度的，一旦声明，它们的长度不能增长或缩小。
*/
fn main() {
    /*
    整型的默认类型是 i32。Rust中整型溢出表现形式：
    1、在 debug 模式编译时，rust 会检查这类问题并使程序 panic
    2、在 release 构建中，rust不会检测一处，相反会进行一种被称为二进制补码包装的操作。
        比如：u8 的范围是 0-255，当赋值为256时，会变成0，赋值为257时会变成1，以此类推。
    */
    let _a: i64 = 98_222; // 声明变量时可以显式的指定类型，数字字面值允许使用 _ 做为分隔符以方便读数
    println!("_a = {}", _a);

    /*
    浮点型默认是 f64，因为在现代 cpu 中，它与 f32 速度几乎一样，不过精度更高。
    */
    let _x = 2.0; // f64 双精度
    let _y: f32 = 3.0; // f32 单精度
    let _b = true;
    let _b: bool = false; // 显式指定类型
    let _c = 'z';
    let c: char = 'X';
    println!("char c = {}", c);

    /*
    元组使用包含圆括号中的逗号分隔的值列表来创建一个元组，元组中的每一个位置都有一个类型，而这些类型不必是相同的。
    和大多数编程语言一样，元组的第一个索引值是 0。
    */
    let tup: (i32, f64, u8) = (500, 6.4, 1); // 元组的每个元素的类型注解是可选的
    let (x, y, z) = tup; // 使用模式匹配来解构元组的值
    println!("x = {}, y = {}, z = {}", x, y, z);
    // 除了使用模式匹配解构元组外，还可以用点号 (.) 后跟值的索引来访问它们。
    let five_hundred = tup.0;
    let six_point_four = tup.1;
    println!(
        "five_hundred = {}, six_point_four = {}",
        five_hundred, six_point_four
    );

    /*
    数组中的每个元素的类型必须相同，且数组的长度是固定的，一旦声明，它们的长度不能增长或缩小。和元组使用圆括号不同，数组使用中括号。
    当你想要在栈(stack)而不是在堆(heap)上为数据分配空间，或者是想要确保总是有固定数量的元素时，数组非常有用。
    */
    let a = [1, 2, 3, 4, 5]; // 数组中的值位于中括号内的逗号分隔的列表中
    let a: [i32; 5] = [6, 7, 8, 9, 10]; // 可以在前面的中括号中包含每个元素的类型，后面跟一个分号，再指定数组的长度
    let a = [3; 5]; // 这样创建的数组每个元素都是 3，其元素个数为 5
    let first = a[0];
    let second = a[1];
    // let not_exist = a[10]; // 当访问越界时，可以编译但是在运行时会崩溃:  index out of bounds: the length is 5 but the index is 10
}
