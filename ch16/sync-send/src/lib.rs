/*
Rust 的并发模型中一个有趣的方面是：语言本身对并发知之甚少。我们之前讨论的几乎所有内容，都属于标准库，而不是语言本身的内容。
由于不需要语言提供并发相关的基础设施，并发方案不受标准库或语言所限，我们可以编写自己的或使用别人编写的并发功能。
然而有两个并发概念是内嵌于语言中的：std::marker 中的 Sync 和 Send trait：
- 通过 Send 允许在线程间转移所有权
    Send 标记 trait 表明类型的所有权可以在线程间传递。几乎所有的 Rust 类型都是 Send 的，不过有一些例外，包括 Rc<T> :这是不能 Send 的，
    因为如果克隆了 Rc<T> 的值并尝试将克隆的所有权转移到另一个线程，这两个线程都可能同时更新引用计数。为此，Rc<T> 被实现为用于单线程场景，
    这时不需要为拥有线程安全的引用计数而付出性能代价。
- Sync 允许多线程访问


通常并不需要手动实现 Send 和 Sync trait，因为由 Send 和 Sync 的类型组成的类型，自动就是 Send 和 Sync 的。
因为他们是标记 trait，甚至都不需要实现任何方法。他们只是用来加强并发相关的不可变性的。
*/
